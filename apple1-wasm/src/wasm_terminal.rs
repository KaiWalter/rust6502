use crossbeam_channel::*;
use wasm_bindgen::{prelude::*, Clamped, JsCast};
use web_sys::*;

use crate::wasm_helpers::*;

const CHAR_HEIGHT: usize = 8;
const CHAR_WIDTH: usize = 8;
const ROWS: u32 = 25;
const COLS: u32 = 40;

pub struct WasmTerminal {
    rx_input: Receiver<u8>,
    rx_output: Receiver<u8>,
    context: CanvasRenderingContext2d,
    cursor_x: usize,
    cursor_y: usize,
    char_buffer: Vec<u8>,
    pixel_buffer: Vec<u8>,
    char_map: Vec<u8>,
}

impl WasmTerminal {
    pub fn new(rx_output: Receiver<u8>) -> WasmTerminal {
        // init canvas
        let document = web_sys::window().unwrap().document().unwrap();
        let canvas = document.get_element_by_id("canvas").unwrap();
        let canvas: web_sys::HtmlCanvasElement = canvas
            .dyn_into::<web_sys::HtmlCanvasElement>()
            .map_err(|_| ())
            .unwrap();

        let context = canvas
            .get_context("2d")
            .unwrap()
            .unwrap()
            .dyn_into::<web_sys::CanvasRenderingContext2d>()
            .unwrap();
        canvas.set_width(COLS * CHAR_WIDTH as u32);
        canvas.set_height(ROWS * CHAR_HEIGHT as u32);

        let (tx_input, rx_input): (Sender<u8>, Receiver<u8>) = unbounded();

        let keydown_closure = Closure::wrap(Box::new(move |event: web_sys::KeyboardEvent| {
            match tx_input.send(event.key_code() as u8) {
                Ok(()) => {}
                Err(e) => log(&e.to_string()),
            }
        }) as Box<dyn FnMut(_)>);

        document
            .add_event_listener_with_callback("keydown", keydown_closure.as_ref().unchecked_ref())
            .map_err(|_| ())
            .unwrap();

        keydown_closure.forget();

        WasmTerminal {
            rx_input,
            rx_output,
            context,
            cursor_x: 0,
            cursor_y: 0,
            char_buffer: vec![0x00; COLS as usize * ROWS as usize],
            pixel_buffer: vec![0; COLS as usize * CHAR_WIDTH * ROWS as usize * CHAR_HEIGHT * 4],
            char_map: vec![
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e,
                0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08,
                0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x14, 0x14, 0x3e, 0x14, 0x3e, 0x14, 0x14, 0x00, 0x08, 0x3c, 0x0a, 0x1c, 0x28, 0x1e,
                0x08, 0x00, 0x06, 0x26, 0x10, 0x08, 0x04, 0x32, 0x30, 0x00, 0x04, 0x0a, 0x0a, 0x04,
                0x2a, 0x12, 0x2c, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04,
                0x02, 0x02, 0x02, 0x04, 0x08, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00,
                0x08, 0x2a, 0x1c, 0x08, 0x1c, 0x2a, 0x08, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x3e,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20,
                0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x1c, 0x22, 0x32, 0x2a, 0x26, 0x22, 0x1c, 0x00,
                0x08, 0x0c, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x00, 0x1c, 0x22, 0x20, 0x18, 0x04, 0x02,
                0x3e, 0x00, 0x3e, 0x20, 0x10, 0x18, 0x20, 0x22, 0x1c, 0x00, 0x10, 0x18, 0x14, 0x12,
                0x3e, 0x10, 0x10, 0x00, 0x3e, 0x02, 0x1e, 0x20, 0x20, 0x22, 0x1c, 0x00, 0x38, 0x04,
                0x02, 0x1e, 0x22, 0x22, 0x1c, 0x00, 0x3e, 0x20, 0x10, 0x08, 0x04, 0x04, 0x04, 0x00,
                0x1c, 0x22, 0x22, 0x1c, 0x22, 0x22, 0x1c, 0x00, 0x1c, 0x22, 0x22, 0x3c, 0x20, 0x10,
                0x0e, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00,
                0x08, 0x08, 0x04, 0x00, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00, 0x00, 0x00,
                0x3e, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00,
                0x1c, 0x22, 0x10, 0x08, 0x08, 0x00, 0x08, 0x00, 0x1c, 0x22, 0x2c, 0x2a, 0x2a, 0x2a,
                0x1c, 0x00, 0x08, 0x14, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x00, 0x1e, 0x22, 0x22, 0x1e,
                0x22, 0x22, 0x1e, 0x00, 0x1c, 0x22, 0x02, 0x02, 0x02, 0x22, 0x1c, 0x00, 0x1e, 0x22,
                0x22, 0x22, 0x22, 0x22, 0x1e, 0x00, 0x3e, 0x02, 0x02, 0x1e, 0x02, 0x02, 0x3e, 0x00,
                0x3e, 0x02, 0x02, 0x1e, 0x02, 0x02, 0x02, 0x00, 0x1c, 0x22, 0x02, 0x3a, 0x22, 0x22,
                0x1c, 0x00, 0x22, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x22, 0x00, 0x1c, 0x08, 0x08, 0x08,
                0x08, 0x08, 0x1c, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x12, 0x0c, 0x00, 0x22, 0x12,
                0x0a, 0x06, 0x0a, 0x12, 0x22, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x3e, 0x00,
                0x22, 0x36, 0x2a, 0x2a, 0x22, 0x22, 0x22, 0x00, 0x22, 0x22, 0x26, 0x2a, 0x32, 0x22,
                0x22, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x1e, 0x22, 0x22, 0x1e,
                0x02, 0x02, 0x02, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x2a, 0x12, 0x2c, 0x00, 0x1e, 0x22,
                0x22, 0x1e, 0x22, 0x22, 0x22, 0x00, 0x1c, 0x22, 0x02, 0x1c, 0x20, 0x22, 0x1c, 0x00,
                0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                0x1c, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x14, 0x08, 0x00, 0x22, 0x22, 0x22, 0x2a,
                0x2a, 0x2a, 0x14, 0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x22, 0x22,
                0x22, 0x14, 0x08, 0x08, 0x08, 0x00, 0x3e, 0x20, 0x10, 0x08, 0x04, 0x02, 0x3e, 0x00,
                0x3e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x3e, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20,
                0x00, 0x00, 0x3e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3e, 0x00, 0x00, 0x00, 0x08, 0x14,
                0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x02, 0x04,
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x20, 0x3c, 0x22, 0x3c, 0x00,
                0x02, 0x02, 0x1e, 0x22, 0x22, 0x22, 0x1e, 0x00, 0x00, 0x00, 0x3c, 0x02, 0x02, 0x02,
                0x3c, 0x00, 0x20, 0x20, 0x3c, 0x22, 0x22, 0x22, 0x3c, 0x00, 0x00, 0x00, 0x1c, 0x22,
                0x3e, 0x02, 0x3c, 0x00, 0x18, 0x24, 0x04, 0x1e, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
                0x1c, 0x22, 0x22, 0x3c, 0x20, 0x1c, 0x02, 0x02, 0x1e, 0x22, 0x22, 0x22, 0x22, 0x00,
                0x08, 0x00, 0x0c, 0x08, 0x08, 0x08, 0x1c, 0x00, 0x10, 0x00, 0x18, 0x10, 0x10, 0x10,
                0x12, 0x0c, 0x02, 0x02, 0x22, 0x12, 0x0e, 0x12, 0x22, 0x00, 0x0c, 0x08, 0x08, 0x08,
                0x08, 0x08, 0x1c, 0x00, 0x00, 0x00, 0x36, 0x2a, 0x2a, 0x2a, 0x22, 0x00, 0x00, 0x00,
                0x1e, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x00,
                0x00, 0x00, 0x1e, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x00, 0x00, 0x3c, 0x22, 0x22, 0x3c,
                0x20, 0x20, 0x00, 0x00, 0x3a, 0x06, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x3c, 0x02,
                0x1c, 0x20, 0x1e, 0x00, 0x00, 0x04, 0x1e, 0x04, 0x04, 0x24, 0x18, 0x00, 0x00, 0x00,
                0x22, 0x22, 0x22, 0x32, 0x2c, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x08, 0x00,
                0x00, 0x00, 0x22, 0x22, 0x2a, 0x2a, 0x36, 0x00, 0x00, 0x00, 0x22, 0x14, 0x08, 0x14,
                0x22, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x3c, 0x20, 0x1c, 0x00, 0x00, 0x3e, 0x10,
                0x08, 0x04, 0x3e, 0x00, 0x38, 0x0c, 0x0c, 0x06, 0x0c, 0x0c, 0x38, 0x00, 0x08, 0x08,
                0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0e, 0x00,
                0x2c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
        }
    }

    pub fn check_input(&self) -> Result<u8, TryRecvError> {
        self.rx_input.try_recv()
    }

    pub fn event_loop(&mut self) {
        let mut screen_changed = false;

        loop {
            match self.rx_output.try_recv() {
                Ok(b) => {
                    // log(&format!("B:{} {} {}", b, self.cursor_x, self.cursor_y));

                    // clear cursor
                    let current_buffer_pos = self.cursor_x + self.cursor_y * COLS as usize;
                    self.display_char(
                        self.cursor_x,
                        self.cursor_y,
                        self.char_buffer[current_buffer_pos],
                        false,
                    );

                    let c = (b & !0x80).to_ascii_uppercase() as u8;
                    match c {
                        0x0A | 0x0D => {
                            self.cursor_x = 0;
                            self.cursor_y += 1;
                        }
                        _ => {
                            if b >= 0x20 && b <= 0x5F {
                                self.char_buffer[current_buffer_pos] = b;
                                self.display_char(self.cursor_x, self.cursor_y, b, false);
                                self.cursor_x += 1;
                            }
                        }
                    }

                    // log(&format!("A:{} {} {}", b, self.cursor_x, self.cursor_y));

                    // check cursor position
                    if self.cursor_x == COLS as usize {
                        self.cursor_x = 0;
                        self.cursor_y += 1;
                    }

                    if self.cursor_y == ROWS as usize {
                        // scroll up
                        for y in 0..(ROWS - 1) as usize {
                            for x in 0..COLS as usize {
                                let new_buffer_pos = x + y * COLS as usize;
                                self.char_buffer[new_buffer_pos] =
                                    self.char_buffer[new_buffer_pos + COLS as usize];
                                self.display_char(x, y, self.char_buffer[new_buffer_pos], false);
                            }
                        }

                        for x in 0..COLS as usize {
                            let new_buffer_pos = x + (ROWS as usize - 1) * COLS as usize;
                            self.char_buffer[new_buffer_pos] = 0x00;
                            self.display_char(
                                x,
                                ROWS as usize - 1,
                                self.char_buffer[new_buffer_pos],
                                false,
                            );
                        }
                        self.cursor_y -= 1;
                    }

                    // display cursor
                    let new_buffer_pos = self.cursor_x + self.cursor_y * COLS as usize;
                    self.display_char(
                        self.cursor_x,
                        self.cursor_y,
                        self.char_buffer[new_buffer_pos],
                        true,
                    );

                    screen_changed = true;
                }
                Err(_) => break,
            }
        }

        if screen_changed {
            self.render();
        }
    }

    pub fn display_char(&mut self, x: usize, y: usize, b: u8, invers: bool) {
        let mut char_pixels: Vec<u8> = Vec::with_capacity(8 * 8);
        let char_offset = b as usize * 8;

        let (set_bit, clear_bit) = if invers { (0, 1) } else { (1, 0) };

        for r in 0..8 {
            let row = self.char_map[char_offset + r];
            let mut mask = 0x01;
            while mask > 0 {
                if row & mask > 0 {
                    char_pixels.push(set_bit)
                } else {
                    char_pixels.push(clear_bit);
                }
                mask = mask.wrapping_shl(1);
            }
        }

        for r in 0..=7 {
            for c in 0..=7 {
                let char_index = r * CHAR_WIDTH + c;
                let pixel_index =
                    ((y * CHAR_HEIGHT + r) * 40 * CHAR_WIDTH + (x * CHAR_WIDTH + c)) * 4;
                self.pixel_buffer[pixel_index + 0] = char_pixels[char_index] * 0x33;
                self.pixel_buffer[pixel_index + 1] = char_pixels[char_index] * 0xff;
                self.pixel_buffer[pixel_index + 2] = char_pixels[char_index] * 0x66;
                self.pixel_buffer[pixel_index + 3] = 0xff;
            }
        }
    }

    pub fn render(&self) {
        let image = ImageData::new_with_u8_clamped_array_and_sh(
            Clamped(&self.pixel_buffer),
            COLS * CHAR_WIDTH as u32,
            ROWS * CHAR_HEIGHT as u32,
        )
        .unwrap();
        self.context.put_image_data(&image, 0., 0.).unwrap();
    }
}
